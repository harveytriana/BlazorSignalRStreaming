@using Microsoft.AspNetCore.SignalR.Client
@using System.Threading
@page "/streaming-in1"
@inject NavigationManager NavigationManager
@implements IAsyncDisposable

<h3><i class="oi oi-cloud-download"></i> SignalR Streaming In</h3>
<hr />
<h5>
    The client receives a stream of the Server.
</h5>
<br />
<div>
    <button class="btn btn-primary"
            style="width:130px;"
            disabled="@(state=="CANCEL")"
            @onclick="Start">
        Start
    </button>
    <button class="btn btn-danger"
            style="width:130px;"
            disabled="@(state=="START")"
            @onclick="Cancel">
        Cancel
    </button>
</div>
<hr />
<ul>
    @foreach (var i in ls) {
        <li>@i</li>
    }
</ul>
<p>
    @status
</p>

@code{
    string state = "START";
    bool cancel;
    string status;
    List<string> ls = new();

    HubConnection _connection;
    CancellationTokenSource _cts;

    bool _connected;

    async Task Start()
    {
        state = "CANCEL";
        status = "";
        cancel = false;
        ls.Clear();

        await ConnectAsync();
        if (_connected) {
            await StartDownlodStream();
        }
    }

    public async Task StartDownlodStream()
    {
        // The correct syntax is:
        await foreach (var count in _connection.StreamAsync<int>("CounterEnumerable", 12, 333, _cts.Token)) {
            ls.Add($"Received {count}");
            StateHasChanged();
        }
        status = "Completed";
        state = "START";
        await DisposeAsync();
    }

    async Task Cancel()
    {
        try {
            _cts.Cancel();
            status = "Canceled.";
            state = "START";
            await DisposeAsync();
        }
        catch
        {

        }
    }

    void Prompt(string message)
    {
        if (message == "COMPLETED") {
            status = "Completed.";
            state = "START";
        }
        else if (message == "CANCEL") {
            status = "Canceled.";
            state = "START";
        }
        else {
            ls.Add(message);
        }
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        if (_connected) {
            await _connection.StopAsync();
            await _connection.DisposeAsync();
            await Task.Delay(300);
            _connected = false;
        }
    }

    async Task ConnectAsync()
    {
        _connected = false;

        var hubUrl = NavigationManager.ToAbsoluteUri("/StreamSender").ToString();
        try {
            _connection = new HubConnectionBuilder()
                .WithUrl(hubUrl)
                .Build();

            _cts = new CancellationTokenSource();

            await _connection.StartAsync(_cts.Token);

            _connected = true;
        }
        catch (Exception exception) {
            status = $"Exception: {exception.Message}";
            _connected = false;
        }
    }
}