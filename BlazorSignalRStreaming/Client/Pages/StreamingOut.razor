@page "/streaming-out"
@inject NavigationManager NavigationManager
@implements IAsyncDisposable

<h3><i class="oi oi-cloud-upload"></i> SignalR Streaming Out</h3>
<hr />
<h5>
    The Clint send a stream to Server
</h5>
<br />
<div>
    <button class="btn btn-primary"
            style="width:130px;"
            disabled="@(state=="CANCEL")"
            @onclick="Start">
        Start
    </button>
    <button class="btn btn-danger"
            style="width:130px;"
            disabled="@(state=="START")"
            @onclick="Cancel">
        Cancel
    </button>
</div>
<hr />
<ul>
    @foreach (var i in ls) {
        <li>@i</li>
    }
</ul>
<p>
    @prompt
</p>

@code{
    string state;
    bool disabled;
    bool cancel;
    string prompt;
    List<string> ls = new();

    const int N = 16;

    StreamingHandler _streamingHandler;

    async Task Start()
    {
        ls.Clear();
        state = "CANCEL";
        cancel = false;
        prompt = "";

        var serviceUrl = NavigationManager.ToAbsoluteUri("/StreamSender").ToString();
        _streamingHandler = new StreamingHandler(serviceUrl);
        await _streamingHandler.ConnectAsync();
        _streamingHandler.Prompt += (s) => Echo(s);

        // TWO APPROACHS
        // await _streamingHandler.SendStreamChannel();
        await _streamingHandler.SendStreamEnumerable();

        // another sample
        // await _streamingClient.SendStreamBasicDemotration();

        if (!cancel) prompt = "End stream.";
        // end task
        state = "START";
    }

    async Task Cancel()
    {
        cancel = true;
        await Task.Delay(300);
        prompt = "Canceled.";
    }

    protected override void OnInitialized()
    {
        state = "START";

    }

    void Echo(string text)
    {
        ls.Add(text);

        if (text == "COMPLETED") {
            if (!cancel) prompt = "End stream.";
            // end task
            state = "START";
        }

        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        if (_streamingHandler != null) {
            _streamingHandler.Dispose();
            await Task.Delay(300);
        }
    }
}